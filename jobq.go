// Code generated by jobq. DO NOT EDIT.
// This file was generated at {{ .CreatedAt }}
package jobq

import (
	"sync"
	"sync/atomic"
	"time"
)

type DoFunc func(task *Task) (*Result, error)

//
// counter
//

type counter struct {
	wg sync.WaitGroup

	count     uint64
	processed uint64

	createdAt time.Time
}

func newJobsCounter() *counter {
	return &counter{
		createdAt: time.Now(),
	}
}

func (j *counter) progress() float64 {
	processed := atomic.LoadUint64(&j.processed)
	count := atomic.LoadUint64(&j.count)
	return float64(processed) / float64(count)
}

func (j *counter) speed() float64 {
	processed := atomic.LoadUint64(&j.processed)
	return float64(processed) / time.Since(j.createdAt).Seconds()
}

func (j *counter) wait() {
	j.wg.Wait()
}

func (j *counter) incCount() {
	atomic.AddUint64(&j.count, 1)
	j.wg.Add(1)
}

func (j *counter) incProcessed() {
	atomic.AddUint64(&j.processed, 1)
	j.wg.Done()
}

//
// result
//

type result struct {
	res *Result
	err error
}

//
// results
//

type results struct {
	capacity int
	results  chan result
}

func newResultsStorage(capacity int) *results {
	return &results{
		capacity: capacity,
		results:  make(chan result, capacity),
	}
}

func (r *results) store(res *Result, err error) {
	r.results <- result{
		res: res,
		err: err,
	}
}

func (r *results) next(res **Result, err *error) bool {
	rr, ok := <-r.results
	if !ok {
		return false
	}

	if res != nil {
		*res = rr.res
	}

	if err != nil {
		*err = rr.err
	}

	return true
}

func (r *results) close() {
	close(r.results)
}

//
// job
//

type job struct {
	task *Task

	counter *counter
	results *results

	wrapped *job
}

func newJob(task *Task, jc *counter, rs *results, j *job) *job {
	return &job{
		task:    task,
		counter: jc,
		results: rs,
		wrapped: j,
	}
}

func (j *job) onAdd() {
	j.counter.incCount()

	if j.wrapped != nil {
		j.wrapped.onAdd()
	}
}

func (j *job) onResult(res *Result, err error) {
	j.counter.incProcessed()

	j.results.store(res, err)

	if j.wrapped != nil {
		j.wrapped.onResult(res, err)
	}
}

//
// queue
//

type queue struct {
	do DoFunc

	capacity     int
	workersCount int

	workersWG sync.WaitGroup
	retriesWG sync.WaitGroup

	todo chan *job

	results *results
	counter *counter
}

func newQueue(do DoFunc, workers int, capacity int) *queue {
	return &queue{
		do:           do,
		capacity:     capacity,
		workersCount: workers,
		todo:         make(chan *job, capacity),
		results:      newResultsStorage(capacity),
		counter:      newJobsCounter(),
	}
}

func (q *queue) Start() {
	for i := 0; i < q.workersCount; i++ {
		q.workersWG.Add(1)
		go q.worker(i)
	}
}

func (q *queue) Stop() {
	close(q.todo)
	q.workersWG.Wait()
	q.results.close()
}

func (q *queue) Add(task *Task) {
	q.add(q.job(task))
}

func (q *queue) Next(res **Result, err *error) bool {
	return q.results.next(res, err)
}

func (q *queue) Progress() float64 {
	return q.counter.progress()
}

func (q *queue) Speed() float64 {
	return q.counter.speed()
}

func (q *queue) Wait() {
	q.counter.wait()
}

func (q *queue) Group() *group {
	return &group{
		queue:   q,
		results: newResultsStorage(q.capacity),
		counter: newJobsCounter(),
	}
}

func (q *queue) job(task *Task) *job {
	return newJob(task, q.counter, q.results, nil)
}

func (q *queue) add(j *job) {
	j.onAdd()
	q.retriesWG.Wait()
	q.todo <- j
}

func (q *queue) worker(id int) {
	defer q.workersWG.Done()

	for j := range q.todo {
		q.process(j)
	}
}

func (q *queue) process(j *job) {
	res, err := q.do(j.task)

	if err != nil {
		if _, ok := err.(*retryable); ok {
			q.retry(j)
			return
		}
	}

	j.onResult(res, err)
}

func (q *queue) retry(j *job) {
	q.retriesWG.Add(1)

	go func() {
		defer q.retriesWG.Done()
		q.todo <- j
	}()
}

//
// group
//

type group struct {
	queue   *queue
	counter *counter
	results *results
}

func (g *group) Add(task *Task) {
	job := g.queue.job(task)
	g.queue.add(newJob(task, g.counter, g.results, job))
}

func (g *group) Next(res **Result, err *error) bool {
	return g.results.next(res, err)
}

func (g *group) Progress() float64 {
	return g.counter.progress()
}

func (g *group) Speed() float64 {
	return g.counter.speed()
}

func (g *group) Wait() {
	g.counter.wait()
}

func (g *group) Close() {
	g.results.close()
}

//
// Errors
//

// retryable represents error which indicates
// that task must retrited.
type retryable struct {
	err error
}

// Error allows retryable to implement error interface.
func (r *retryable) Error() string {
	if r.err != nil {
		return r.err.Error()
	}

	return "retry"
}

// ErrRetry is error to return from DoFunc when retry is required.
var ErrRetry = &retryable{}

// Retry wraps given error and returns retryable error.
func Retry(err error) error {
	return &retryable{err}
}
