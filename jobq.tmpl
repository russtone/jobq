// Code generated by jobq. DO NOT EDIT.
// This file was generated at {{ .CreatedAt }}
package {{ .Package }}

import (
	"sync"
	"sync/atomic"
	"time"
)

type DoFunc func(task *{{ .Task }}) (*{{ .Result }}, error)

type job struct {
	task *{{ .Task }}

	onDone   func()
	onResult func(res {{ .Result }})
	onError  func(err error)
}

type Queue struct {
	do DoFunc

	workersCount int
	workersWG    sync.WaitGroup

	jobsWG        sync.WaitGroup
	jobsCount     uint64
	jobsProcessed uint64

	retriesWG sync.WaitGroup

	todo chan job
	done chan {{ .Result }}
	errs chan error

	createdAt time.Time
}

func newQueue(do DoFunc, workers int, capacity int) *Queue {
	return &Queue{
		do:           do,
		workersCount: workers,
		todo:         make(chan job, capacity),
		done:         make(chan {{ .Result }}, capacity),
		errs:         make(chan error, capacity),
		createdAt:    time.Now(),
	}
}

type addOptions struct {
	dest *{{ .Result }}
}

type AddOption func(*addOptions)

func Dest(dest *{{ .Result }}) AddOption {
	return func(opts *addOptions) {
		opts.dest = dest
	}
}

func (q *Queue) Add(task *{{ .Task }}, opts ...AddOption) {
	options := &addOptions{}

	for _, opt := range opts {
		opt(options)
	}

	q.add(job{task: task, onResult: func(res {{ .Result }}) {
		if options.dest != nil {
			*options.dest = res
		}
	}})
}

func (q *Queue) Next(dest *{{ .Result }}) bool {
	res, ok := <-q.done
	if !ok {
		return false
	}

	if dest != nil {
		*dest = res
	}

	return true
}

func (q *Queue) Err(e *error) bool {
	err, ok := <-q.errs
	if !ok {
		return false
	}

	*e = err
	return true
}

func (q *Queue) Start() {
	for i := 0; i < q.workersCount; i++ {
		q.workersWG.Add(1)
		go q.worker(i)
	}

	go func() {
		q.workersWG.Wait()
		close(q.done)
		close(q.errs)
	}()
}

func (q *Queue) Stop() {
	close(q.todo)
}

func (q *Queue) WaitWorkers() {
	q.workersWG.Wait()
}

func (q *Queue) WaitJobs() {
	q.jobsWG.Wait()
}

func (q *Queue) Progress() float64 {
	processed := atomic.LoadUint64(&q.jobsProcessed)
	return float64(processed) / float64(q.jobsCount)
}

func (q *Queue) Speed() float64 {
	processed := atomic.LoadUint64(&q.jobsProcessed)
	return float64(processed) / time.Since(q.createdAt).Seconds()
}

func (q *Queue) Group() *Group {
	return &Group{
		queue:     q,
		createdAt: time.Now(),
	}
}

func (q *Queue) add(j job) {
	atomic.AddUint64(&q.jobsCount, 1)
	q.jobsWG.Add(1)
	q.retriesWG.Wait()
	q.todo <- j
}

func (q *Queue) worker(id int) {
	defer q.workersWG.Done()

	for j := range q.todo {
		q.process(j)
	}
}

func (q *Queue) process(j job) {
	res, err := q.do(j.task)

	if err != nil {
		if _, ok := err.(*retryable); ok {
			q.retry(j)
			return
		}

		if j.onError != nil {
			j.onError(err)
		}
		q.errs <- err
	}

	defer func() {
		q.jobsWG.Done()
		atomic.AddUint64(&q.jobsProcessed, 1)
		if j.onDone != nil {
			j.onDone()
		}
	}()

	if err != nil || res == nil {
		return
	}

	if j.onResult != nil {
		j.onResult(*res)
	}

	q.done <- *res
}

func (q *Queue) retry(j job) {
	q.retriesWG.Add(1)

	go func() {
		defer q.retriesWG.Done()
		q.todo <- j
	}()
}

var ErrRetry = &retryable{}

func Retry(err error) error {
	return &retryable{err}
}

type retryable struct {
	err error
}

func (r *retryable) Error() string {
	if r.err != nil {
		return r.err.Error()
	}

	return "retry"
}

type Group struct {
	queue *Queue

	jobsWG        sync.WaitGroup
	jobsCount     uint64
	jobsProcessed uint64

	createdAt time.Time
}

func (g *Group) Add(task *{{ .Task }}) {
	atomic.AddUint64(&g.jobsCount, 1)
	g.jobsWG.Add(1)
	g.queue.add(job{task: task, onDone: func() {
		atomic.AddUint64(&g.jobsProcessed, 1)
		g.jobsWG.Done()
	}})
}

func (g *Group) Wait() {
	g.jobsWG.Wait()
}

func (g *Group) Progress() float64 {
	processed := atomic.LoadUint64(&g.jobsProcessed)
	return float64(processed) / float64(g.jobsCount)
}

func (g *Group) Speed() float64 {
	processed := atomic.LoadUint64(&g.jobsProcessed)
	return float64(processed) / time.Since(g.createdAt).Seconds()
}
